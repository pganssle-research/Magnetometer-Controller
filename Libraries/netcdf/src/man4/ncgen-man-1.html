<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Mon Apr 12 12:49:44 2010 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title>NCGEN</title>
</head>
<body>

<h1 align=center>NCGEN</h1>
<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#USAGE">USAGE</a><br>
<a href="#BUGS">BUGS</a><br>

<hr>
<a name="NAME"></a>
<h2>NAME</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>ncgen &minus; From a CDL file generate a netCDF-3 file, a
netCDF-4 file or a C program</p>
</td>
</table>
<a name="SYNOPSIS"></a>
<h2>SYNOPSIS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>ncgen [-b] [-c] [-f] [-k <i>file format</i>] [-l
<i>output language</i>] [-n] [-o <i>netcdf_filename</i>]
[-x] <i>input_file</i></p>
</td>
</table>
<a name="DESCRIPTION"></a>
<h2>DESCRIPTION</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>ncgen</b> generates either a netCDF-3 (i.e. classic)
binary .nc file, a netCDF-4 (i.e. enhanced) binary .nc file
or a file in some source language that when executed will
construct the corresponding binary .nc file. The input to
<b>ncgen</b> is a description of a netCDF file in a small
language known as CDL (network Common Data form Language),
described below. If no options are specified in invoking
<b>ncgen</b>, it merely checks the syntax of the input CDL
file, producing error messages for any violations of CDL
syntax. Other options can be used, for example, to create
the corresponding netCDF file, or to generate a C program
that uses the netCDF C interface to create the netCDF
file.</p>
<!-- INDENTATION -->
<p>Note that this version of ncgen was originally called
ncgen4. The older ncgen program has been renamed to
ncgen3.</p>
<!-- INDENTATION -->
<p><b>ncgen</b> may be used with the companion program
<b>ncdump</b> to perform some simple operations on netCDF
files. For example, to rename a dimension in a netCDF file,
use <b>ncdump</b> to get a CDL version of the netCDF file,
edit the CDL file to change the name of the dimensions, and
use <b>ncgen</b> to generate the corresponding netCDF file
from the edited CDL file.</p>
</td>
</table>
<a name="OPTIONS"></a>
<h2>OPTIONS</h2>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">

<p><b>-b</b></p>
</td>
<td width="5%"></td>
<td width="77%">

<p>Create a (binary) netCDF file. If the <b>-o</b> option
is absent, a default file name will be constructed from the
netCDF name (specified after the <b>netcdf</b> keyword in
the input) by appending the &lsquo;.nc&rsquo; extension. If
a file already exists with the specified name, it will be
overwritten.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">

<p><b>-c</b></p>
</td>
<td width="5%"></td>
<td width="77%">

<p>Generate <b>C</b> source code that will create a netCDF
file matching the netCDF specification. The C source code is
written to standard output; equivalent to -lc.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">

<p><b>-f</b></p>
</td>
<td width="5%"></td>
<td width="77%">

<p>Generate <b>FORTRAN 77</b> source code that will create
a netCDF file matching the netCDF specification. The source
code is written to standard output; equivalent to -lf77.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>-o</b> netcdf_file</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Name for the binary netCDF file created. If this option
is specified, it implies the &quot;<b>-b</b>&quot; option.
(This option is necessary because netCDF files cannot be
written directly to standard output, since standard output
is not seekable.)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>-k</b> file_format</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>The -k flag specifies the format of the file to be
created and, by inference, the data model accepted by ncgen
(i.e. netcdf-3 (classic) versus netcdf-4). The possible
arguments are as follows.</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="30%"></td>
<td width="69%">
<p>&rsquo;1&rsquo;, &rsquo;classic&rsquo; =&gt; netcdf
classic file format, netcdf-3 type model.</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="30%"></td>
<td width="69%">
<p>&rsquo;2&rsquo;, &rsquo;64-bit-offset&rsquo;,
&rsquo;64-bit offset&rsquo; =&gt; netcdf 64 bit classic file
format, netcdf-3 type model.</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="30%"></td>
<td width="69%">
<p>&rsquo;3&rsquo;, &rsquo;hdf5&rsquo;,
&rsquo;netCDF-4&rsquo;, &rsquo;enhanced&rsquo; =&gt;
netcdf-4 file format, netcdf-4 type model.</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="30%"></td>
<td width="69%">
<p>&rsquo;4&rsquo;, &rsquo;hdf5-nc3&rsquo;, &rsquo;netCDF-4
classic model&rsquo;, &rsquo;enhanced-nc3&rsquo; =&gt;
netcdf-4 file format, netcdf-3 type model.</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>If no -k is specified then it defaults to -k1 (i.e.
classic). Note also that -v is accepted to mean the same
thing as -k for backward compatibility, but -k is preferred,
to match the corresponding ncdump option.</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="2%">

<p><b>-x</b></p>
</td>
<td width="7%"></td>
<td width="77%">

<p>Don&rsquo;t initialize data with fill values. This can
speed up creation of large netCDF files greatly, but later
attempts to read unwritten data from the generated file will
not be easily detectable.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>-l</b> output_language</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>The -l flag specifies the output language to use when
generating source code that will create or define a netCDF
file matching the netCDF specification. The output is
written to standard output. The currently supported
languages have the following flags.</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="30%"></td>
<td width="69%">
<p>c|C&rsquo; =&gt; C language output.</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="30%"></td>
<td width="69%">
<p>f77|fortran77&rsquo; =&gt; FORTRAN 77 language
output</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="44%"></td>
<td width="55%">
<p>; note that currently only the classic model is
supported.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="30%"></td>
<td width="69%">
<p>j|java&rsquo; =&gt; (experimental) Java language
output</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="44%"></td>
<td width="55%">
<p>; targets the existing Unidata Java interface, which
means that only the classic model is supported.</p></td>
</table>
<a name="EXAMPLES"></a>
<h2>EXAMPLES</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Check the syntax of the CDL file
&lsquo;<b>foo.cdl</b>&rsquo;:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>ncgen foo.cdl</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>From the CDL file &lsquo;<b>foo.cdl</b>&rsquo;, generate
an equivalent binary netCDF file named
&lsquo;<b>x.nc</b>&rsquo;:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>ncgen -o x.nc foo.cdl</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>From the CDL file &lsquo;<b>foo.cdl</b>&rsquo;, generate
a C program containing the netCDF function invocations
necessary to create an equivalent binary netCDF file named
&lsquo;<b>x.nc</b>&rsquo;:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>ncgen -c -o x.nc foo.cdl</p></td>
</table>
<a name="USAGE"></a>
<h2>USAGE</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>CDL Syntax Overview</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Below is an example of CDL syntax, describing a netCDF
file with several named dimensions (lat, lon, and time),
variables (Z, t, p, rh, lat, lon, time), variable attributes
(units, long_name, valid_range, _FillValue), and some data.
CDL keywords are in boldface. (This example is intended to
illustrate the syntax; a real CDL file would have a more
complete set of attributes so that the data would be more
completely self-describing.)</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<pre>netcdf foo {  // an example netCDF specification in CDL

<b>types</b>:
<i>    ubyte enum</i> enum_t {Clear = 0, Cumulonimbus = 1, Stratus = 2};
<i>    opaque</i>(11) opaque_t;
<i>    int</i>(*) vlen_t;

<b>dimensions</b>:
</pre>
</td>
</table>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>lat = 10, lon = 5, time = <i>unlimited</i> ;</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><b>variables</b>:</p></td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p><i>long</i> lat(lat), lon(lon), time(time);</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p><i>float</i> Z(time,lat,lon), t(time,lat,lon);</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p><i>double</i> p(time,lat,lon);</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p><i>long</i> rh(time,lat,lon);</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p><i>string</i> country(time,lat,lon);</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p><i>ubyte</i> tag;</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>// variable attributes</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>lat:long_name = &quot;latitude&quot;;</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>lat:units = &quot;degrees_north&quot;;</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>lon:long_name = &quot;longitude&quot;;</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>lon:units = &quot;degrees_east&quot;;</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>time:units = &quot;seconds since 1992-1-1
00:00:00&quot;;</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>// typed variable attributes</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p><i>string</i> Z:units = &quot;geopotential
meters&quot;;</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p><i>float</i> Z:valid_range = 0., 5000.;</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p><i>double</i> p:_FillValue = -9999.;</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p><i>long</i> rh:_FillValue = -1;</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p><i>vlen_t</i> :globalatt = {17, 18, 19};</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><b>data</b>:</p></td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>lat = 0, 10, 20, 30, 40, 50, 60, 70, 80, 90;</p>
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>lon = -140, -118, -96, -84, -52;</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><b>group</b> g {<b><br>
types</b>:<i><br>
compound</i> cmpd_t { <i>vlen_t</i> f1; <i>enum_t</i>
f2;};<br>
} // group g<b><br>
group</b> h {<b><br>
variables</b>:</p></td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="72%">

<p>/g/<i>cmpd_t</i> compoundvar;</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><b>data</b>:<br>
compoundvar = { {3,4,5}, Stratus } ;<br>
} // group h<br>
}</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>All CDL statements are terminated by a semicolon. Spaces,
tabs, and newlines can be used freely for readability.
Comments may follow the characters &lsquo;//&rsquo; on any
line.</p>
<!-- INDENTATION -->
<p>A CDL description consists of five optional parts:
<i>types</i>, <i>dimensions</i>, <i>variables</i>,
<i>data</i>, beginning with the keyword <b>types:</b>,
<b>dimensions:</b>, <b>variables:</b>, and <b>data</b>,
respectively. The variable part may contain <i>variable
declarations</i> and <i>attribute assignments</i>. All
sections may contain global attribute assignments.</p>
<!-- INDENTATION -->
<p>In addition, after the <b>data:</b> section, the user may
define a series of groups (see the example above). Groups
themselves can contain types, dimensions, variables, data,
and other (nested) groups.</p>
<!-- INDENTATION -->
<p>The netCDF <b>type</b> section declares the user defined
types. These may be constructed using any of the following
types: <b>enum</b>, <b>vlen</b>, <b>opaque</b>, or
<b>compound</b>.</p>
<!-- INDENTATION -->
<p>A netCDF <i>dimension</i> is used to define the shape of
one or more of the multidimensional variables contained in
the netCDF file. A netCDF dimension has a name and a size. A
dimension can have the <b>unlimited</b> size, which means a
variable using this dimension can grow to any length in that
dimension.</p>
<!-- INDENTATION -->
<p>A <i>variable</i> represents a multidimensional array of
values of the same type. A variable has a name, a data type,
and a shape described by its list of dimensions. Each
variable may also have associated <i>attributes</i> (see
below) as well as data values. The name, data type, and
shape of a variable are specified by its declaration in the
<i>variable</i> section of a CDL description. A variable may
have the same name as a dimension; by convention such a
variable is one-dimensional and contains coordinates of the
dimension it names. Dimensions need not have corresponding
variables.</p>
<!-- INDENTATION -->
<p>A netCDF <i>attribute</i> contains information about a
netCDF variable or about the whole netCDF dataset.
Attributes are used to specify such properties as units,
special values, maximum and minimum valid values, scaling
factors, offsets, and parameters. Attribute information is
represented by single values or arrays of values. For
example, &quot;units&quot; is an attribute represented by a
character array such as &quot;celsius&quot;. An attribute
has an associated variable, a name, a data type, a length,
and a value. In contrast to variables that are intended for
data, attributes are intended for metadata (data about
data). Unlike netCDF-3, attribute types can be any user
defined type as well as the usual built-in types.</p>
<!-- INDENTATION -->
<p>In CDL, an attribute is designated by a a type, a
variable, a &rsquo;:&rsquo;, and then an attribute name. The
type is optional and if missing, it will be inferred from
the values assigned to the attribute. It is possible to
assign <i>global</i> attributes not associated with any
variable to the netCDF as a whole by omitting the variable
name in the attribute declaration. Notice that there is a
potential ambiguity in a specification such as</p>
<!-- INDENTATION -->
<pre>x : a = ...
</pre>
<!-- INDENTATION -->
<p>In this situation, x could be either a type for a global
attribute, or the variable name for an attribute. Since
there could both be a type named x and a variable named x,
there is an ambiguity. The rule is that in this situation, x
will be interpreted as a type if possible, and otherwise as
a variable.</p>
<!-- INDENTATION -->
<p>If not specified, the data type of an attribute in CDL is
derived from the type of the value(s) assigned to it. The
length of an attribute is the number of data values assigned
to it, or the number of characters in the character string
assigned to it. Multiple values are assigned to
non-character attributes by separating the values with
commas. All values assigned to an attribute must be of the
same type.</p>
<!-- INDENTATION -->
<p>The names for CDL dimensions, variables, and attributes
must begin with an alphabetic character or &lsquo;_&rsquo;,
and subsequent characters may be alphanumeric or
&lsquo;_&rsquo; or &lsquo;-&rsquo;.</p>
<!-- INDENTATION -->
<p>The optional <i>data</i> section of a CDL specification
is where netCDF variables may be initialized. The syntax of
an initialization is simple: a variable name, an equals
sign, and a comma-delimited list of constants (possibly
separated by spaces, tabs and newlines) terminated with a
semicolon. For multi-dimensional arrays, the last dimension
varies fastest. Thus row-order rather than column order is
used for matrices. If fewer values are supplied than are
needed to fill a variable, it is extended with a
type-dependent &lsquo;fill value&rsquo;, which can be
overridden by supplying a value for a distinguished variable
attribute named &lsquo;_FillValue&rsquo;. The types of
constants need not match the type declared for a variable;
coercions are done to convert integers to floating point,
for example. The constant &lsquo;_&rsquo; can be used to
designate the fill value for a variable.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Primitive Data Types</b></p></td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p><b>char</b></p>
</td>
<td width="7%">

<p>characters</p>
</td>
<td width="7%"></td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p><b>byte</b></p>
</td>
<td width="7%">

<p>8-bit data</p>
</td>
<td width="7%"></td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p><b>short</b></p>
</td>
<td width="7%"></td>
<td width="7%">

<p>16-bit signed integers</p>
</td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p><b>int</b></p>
</td>
<td width="7%">

<p>32-bit signed integers</p>
</td>
<td width="7%"></td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p><b>long</b></p>
</td>
<td width="7%">

<p>(synonymous with <b>int</b>)</p>
</td>
<td width="7%"></td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p><b>int64</b></p>
</td>
<td width="7%"></td>
<td width="7%">

<p>64-bit signed integers</p>
</td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p><b>float</b></p>
</td>
<td width="7%"></td>
<td width="7%">

<p>IEEE single precision floating point (32 bits)</p>
</td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p><b>real</b></p>
</td>
<td width="7%">

<p>(synonymous with <b>float</b>)</p>
</td>
<td width="7%"></td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p><b>double</b></p>
</td>
<td width="7%"></td>
<td width="7%">

<p>IEEE double precision floating point (64 bits)</p>
</td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p><b>ubyte</b></p>
</td>
<td width="7%"></td>
<td width="7%">

<p>unsigned 8-bit data</p>
</td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p><b>ushort</b></p>
</td>
<td width="7%"></td>
<td width="7%">

<p>16-bit unsigned integers</p>
</td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p><b>uint</b></p>
</td>
<td width="7%">

<p>32-bit unsigned integers</p>
</td>
<td width="7%"></td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p><b>uint64</b></p>
</td>
<td width="7%"></td>
<td width="7%">

<p>64-bit unsigned integers</p>
</td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p><b>string</b></p>
</td>
<td width="7%"></td>
<td width="7%">

<p>arbitrary length strings</p>
</td>
<td width="57%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>CDL supports a superset of the primitive data types of C.
The names for the primitive data types are reserved words in
CDL, so the names of variables, dimensions, and attributes
must not be primitive type names. In declarations, type
names may be specified in either upper or lower case.</p>
<!-- INDENTATION -->
<p>Bytes differ from characters in that they are intended to
hold a full eight bits of data, and the zero byte has no
special significance, as it does for character data.
<b>ncgen</b> converts <b>byte</b> declarations to
<b>char</b> declarations in the output C code and to the
nonstandard <b>BYTE</b> declaration in output Fortran
code.</p>
<!-- INDENTATION -->
<p>Shorts can hold values between -32768 and 32767.
<b>ncgen</b> converts <b>short</b> declarations to
<b>short</b> declarations in the output C code and to the
nonstandard <b>INTEGER*2</b> declaration in output Fortran
code.</p>
<!-- INDENTATION -->
<p>Ints can hold values between -2147483648 and 2147483647.
<b>ncgen</b> converts <b>int</b> declarations to <b>int</b>
declarations in the output C code and to <b>INTEGER</b>
declarations in output Fortran code. <b>long</b> is accepted
as a synonym for <b>int</b> in CDL declarations, but is
deprecated since there are now platforms with 64-bit
representations for C longs.</p>
<!-- INDENTATION -->
<p>Int64 can hold values between -9223372036854775808 and
9223372036854775807. <b>ncgen</b> converts <b>int64</b>
declarations to <b>longlong</b> declarations in the output C
code.</p>
<!-- INDENTATION -->
<p>Floats can hold values between about -3.4+38 and 3.4+38.
Their external representation is as 32-bit IEEE normalized
single-precision floating point numbers. <b>ncgen</b>
converts <b>float</b> declarations to <b>float</b>
declarations in the output C code and to <b>REAL</b>
declarations in output Fortran code. <b>real</b> is accepted
as a synonym for <b>float</b> in CDL declarations.</p>
<!-- INDENTATION -->
<p>Doubles can hold values between about -1.7+308 and
1.7+308. Their external representation is as 64-bit IEEE
standard normalized double-precision floating point numbers.
<b>ncgen</b> converts <b>double</b> declarations to
<b>double</b> declarations in the output C code and to
<b>DOUBLE PRECISION</b> declarations in output Fortran
code.</p>
<!-- INDENTATION -->
<p>The unsigned counterparts of the above integer types are
mapped to the corresponding unsigned C types. Their ranges
are suitably modified to start at zero.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>CDL Constants</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Constants assigned to attributes or variables may be of
any of the basic netCDF types. The syntax for constants is
similar to C syntax, except that type suffixes must be
appended to shorts and floats to distinguish them from longs
and doubles.</p>
<!-- INDENTATION -->
<p>A <i>byte</i> constant is represented by a single
character or multiple character escape sequence enclosed in
single quotes. For example,</p></td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="6" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>&rsquo;a&rsquo;</p>
<td width="21%"></td>
<td width="5%"></td>
<td width="7%">
</td>
<td width="7%">

<p>// ASCII &lsquo;a&rsquo;<br>
&rsquo;\0&rsquo;</p>
</td>
<td width="7%"></td>
<td width="49%">
</td>
<tr valign="top" align="left">
<td width="21%"></td>
<td width="5%"></td>
<td width="7%"></td>
<td width="7%">
</td>
<td width="7%">

<p>// a zero byte<br>
&rsquo;\n&rsquo;</p>
</td>
<td width="49%">
</td>
<tr valign="top" align="left">
<td width="21%"></td>
<td width="5%"></td>
<td width="7%"></td>
<td width="7%">
</td>
<td width="7%">

<p>// ASCII newline character<br>
&rsquo;\33&rsquo;</p>
</td>
<td width="49%">
</td>
<tr valign="top" align="left">
<td width="21%"></td>
<td width="5%"></td>
<td width="7%"></td>
<td width="7%">
</td>
<td width="7%">

<p>// ASCII escape character (33 octal)<br>
&rsquo;\x2b&rsquo;</p>
</td>
<td width="49%">
</td>
<tr valign="top" align="left">
<td width="21%"></td>
<td width="5%"></td>
<td width="7%"></td>
<td width="7%">

<p>// ASCII plus (2b hex)<br>
&rsquo;\377&rsquo;</p>
</td>
<td width="7%"></td>
<td width="49%">
</td>
<tr valign="top" align="left">
<td width="21%"></td>
<td width="5%"></td>
<td width="7%"></td>
<td width="7%">

<p>// 377 octal = 255 decimal, non-ASCII</p>
</td>
<td width="7%"></td>
<td width="49%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Character constants are enclosed in double quotes. A
character array may be represented as a string enclosed in
double quotes. The usual C string escape conventions are
honored. For example</p></td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="6" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p>&quot;a&quot;</p>
</td>
<td width="7%">
</td>
<td width="7%">

<p>// ASCII &lsquo;a&rsquo;</p>
</td>
<td width="7%"></td>
<td width="49%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p>&quot;Two\nlines\n&quot;</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%">

<p>// a 10-character string with two embedded newlines</p>
</td>
<td width="49%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p>&quot;a bell:\007&quot;</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%">

<p>// a string containing an ASCII bell</p>
</td>
<td width="49%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Note that the netCDF character array &quot;a&quot; would
fit in a one-element variable, since no terminating NULL
character is assumed. However, a zero byte in a character
array is interpreted as the end of the significant
characters by the <b>ncdump</b> program, following the C
convention. Therefore, a NULL byte should not be embedded in
a character string unless at the end: use the <i>byte</i>
data type instead for byte arrays that contain the zero
byte.</p>
<!-- INDENTATION -->
<p><i>short</i> integer constants are intended for
representing 16-bit signed quantities. The form of a
<i>short</i> constant is an integer constant with an
&lsquo;s&rsquo; or &lsquo;S&rsquo; appended. If a
<i>short</i> constant begins with &lsquo;0&rsquo;, it is
interpreted as octal, except that if it begins with
&lsquo;0x&rsquo;, it is interpreted as a hexadecimal
constant. For example:</p></td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p>-2s</p>
</td>
<td width="7%">

<p>// a short -2</p>
</td>
<td width="7%"></td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p>0123s</p>
</td>
<td width="7%"></td>
<td width="7%">

<p>// octal</p>
</td>
<td width="57%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>0x7ffs //hexadecimal</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><i>int</i> integer constants are intended for
representing 32-bit signed quantities. The form of an
<i>int</i> constant is an ordinary integer constant,
although it is acceptable to append an optional
&lsquo;l&rsquo; or &lsquo;L&rsquo; (again, deprecated). If
an <i>int</i> constant begins with &lsquo;0&rsquo;, it is
interpreted as octal, except that if it begins with
&lsquo;0x&rsquo;, it is interpreted as a hexadecimal
constant (but see opaque constants below). Examples of valid
<i>int</i> constants include:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<pre>-2
1234567890L
</pre>
</td>
</table>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="6" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p>0123</p>
</td>
<td width="7%">
</td>
<td width="7%">

<p>// octal</p>
</td>
<td width="7%"></td>
<td width="49%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p>0x7ff</p>
</td>
<td width="7%"></td>
<td width="7%">
</td>
<td width="7%">

<p>// hexadecimal</p>
</td>
<td width="49%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><i>int64</i> integer constants are intended for
representing 64-bit signed quantities. The form of an
<i>int64</i> constant is an integer constant with an
&lsquo;ll&rsquo; or &lsquo;LL&rsquo; appended. If an
<i>int64</i> constant begins with &lsquo;0&rsquo;, it is
interpreted as octal, except that if it begins with
&lsquo;0x&rsquo;, it is interpreted as a hexadecimal
constant. For example:</p></td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p>-2ll</p>
</td>
<td width="7%">

<p>// an unsigned -2</p>
</td>
<td width="7%"></td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p>0123LL</p>
</td>
<td width="7%"></td>
<td width="7%">

<p>// octal</p>
</td>
<td width="57%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>0x7ffLL //hexadecimal</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Floating point constants of type <i>float</i> are
appropriate for representing floating point data with about
seven significant digits of precision. The form of a
<i>float</i> constant is the same as a C floating point
constant with an &lsquo;f&rsquo; or &lsquo;F&rsquo;
appended. For example the following are all acceptable
<i>float</i> constants:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<pre>-2.0f
</pre>
</td>
</table>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p>3.14159265358979f</p>
</td>
<td width="22%"></td>
<td width="7%">

<p>// will be truncated to less precision</p>
</td>
<td width="42%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>1.f</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Floating point constants of type <i>double</i> are
appropriate for representing floating point data with about
sixteen significant digits of precision. The form of a
<i>double</i> constant is the same as a C floating point
constant. An optional &lsquo;d&rsquo; or &lsquo;D&rsquo; may
be appended. For example the following are all acceptable
<i>double</i> constants:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<pre>-2.0
3.141592653589793
1.0e-20
1.d
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Unsigned integer constants can be created by appending
the character &rsquo;U&rsquo; or &rsquo;u&rsquo; between the
constant and any trailing size specifier. Thus one could say
10U, 100us, 100000ul, or 1000000ull, for example.</p>
<!-- INDENTATION -->
<p><i>String</i> constants are, like character constants,
represented using double quotes. This represents a potential
ambiguity since a multi-character string may also indicate a
dimensioned character value. Disambiguation usually occurs
by context, but care should be taken to specify
the<i>string</i> type to ensure the proper choice.</p>
<!-- INDENTATION -->
<p><i>Opaque</i> constants are represented as sequences of
hexadecimal digits preceded by 0X or 0x: 0xaa34ffff, for
example. These constants can still be used as integer
constants and will be either truncated or extended as
necessary.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Compound Constant Expressions</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>In order to assign values to variables (or attributes)
whose type is user-defined type, the constant notation has
been extended to include sequences of constants enclosed in
curly brackets (e.g. &quot;{&quot;...&quot;}&quot;). Such a
constant is called a compound constant, and compound
constants can be nested.</p>
<!-- INDENTATION -->
<p>Given a type &quot;T(*) vlen_t&quot;, where T is some
other arbitrary base type, constants for this should be
specified as follows.</p>
<!-- INDENTATION -->
<pre>    vlen_t var[2] = {t11,t12,...t1N}, {t21,t22,...t2m};
</pre>
<!-- INDENTATION -->
<p>The values tij, are assumed to be constants of type
T.</p>
<!-- INDENTATION -->
<p>Given a type &quot;compound cmpd_t {T1 f1; T2 f2...Tn
fn}&quot;, where the Ti are other arbitrary base types,
constants for this should be specified as follows.</p>
<!-- INDENTATION -->
<pre>    cmpd_t var[2] = {t11,t12,...t1N}, {t21,t22,...t2n};
</pre>
<!-- INDENTATION -->
<p>The values tij, are assumed to be constants of type Ti.
If the fields are missing, then they will be set using any
specified or default fill value for the field&rsquo;s base
type.</p>
<!-- INDENTATION -->
<p>The general set of rules for using braces are defined in
the <b>Specifying Datalists</b> section below.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Scoping Rules</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>With the addition of groups, the name space for defined
objects is no longer flat. References (names) of any type,
dimension, or variable may be prefixed with the absolute
path specifying a specific declaration. Thus one might
say</p>
<!-- INDENTATION -->
<pre>    variables:
        /g1/g2/t1 v1;
</pre>
<!-- INDENTATION -->
<p>The type being referenced (t1) is the one within group
g2, which in turn is nested in group g1. The similarity of
this notation to Unix file paths is deliberate, and one can
consider groups as a form of directory structure.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>1. When name is not prefixed, then scope rules are
applied to locate the specified declaration. Currently,
there are three rules: one for dimensions, one for types and
enumeration constants, and one for all others.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>2. When an unprefixed name of a dimension is used (as in
a variable declaration), ncgen first looks in the
immediately enclosing group for the dimension. If it is not
found there, then it looks in the group enclosing this
group. This continues up the group hierarchy until the
dimension is found, or there are no more groups to
search.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>3. For all other names, only the immediately enclosing
group is searched.</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>When an unprefixed name of a type or an enumeration
constant is used, ncgen searches the group tree using a
pre-order depth-first search. This essentially means that it
will find the matching declaration that precedes the
reference textually in the cdl file and that is
&quot;highest&quot; in the group hierarchy.</p>
<!-- INDENTATION -->
<p>One final note. Forward references are not allowed. This
means that specifying, for example, /g1/g2/t1 will fail if
this reference occurs before g1 and/or g2 are defined.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Special Attributes</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Special, virtual, attributes can be specified to provide
performance-related information about the file format and
about variable properties. The file must be a netCDF-4 file
for these to take effect.</p>
<!-- INDENTATION -->
<p>These special virtual attributes are not actually part of
the file, they are merely a convenient way to set
miscellaneous properties of the data in CDL</p>
<!-- INDENTATION -->
<p>The special attributes currently supported are as
follows: &lsquo;_Format&rsquo;, &lsquo;_Fletcher32,
&lsquo;_ChunkSizes&rsquo;, &lsquo;_Endianness&rsquo;,
&lsquo;_DeflateLevel&rsquo;, &lsquo;_Shuffle&rsquo;, and
&lsquo;_Storage&rsquo;.</p>
<!-- INDENTATION -->
<p>&lsquo;_Format&rsquo; is a global attribute specifying
the netCDF format variant. Its value must be a single string
matching one of &lsquo;classic&rsquo;, &lsquo;64-bit
offset&rsquo;, &lsquo;netCDF-4&rsquo;, or &lsquo;netCDF-4
classic model&rsquo;.</p>
<!-- INDENTATION -->
<p>The rest of the special attributes are all variable
attributes. Essentially all of then map to some
corresponding &lsquo;nc_def_var_XXX&rsquo; function as
defined in the netCDF-4 API. &lsquo;_Fletcher32 sets the
&lsquo;fletcher32&rsquo; property for a variable.
&lsquo;_Endianness&rsquo; is either &lsquo;little&rsquo; or
&lsquo;big&rsquo;, depending on how the variable is stored
when first written. &lsquo;_DeflateLevel&rsquo; is an
integer between 0 and 9 inclusive if compression has been
specified for the variable. &lsquo;_Shuffle&rsquo; is 1 if
use of the shuffle filter is specified for the variable.
&lsquo;_Storage&rsquo; is &lsquo;contiguous&rsquo; or
&lsquo;chunked&rsquo;. &lsquo;_ChunkSizes&rsquo; is a list
of chunk sizes for each dimension of the variable</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Specifying Datalists</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Specifying datalists for variables in the
&lsquo;data:&lsquo; section can be somewhat complicated.
There are some rules that must be followed to ensure that
datalists are parsed correctly by ncgen.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>1. The top level is automatically assumed to be a list of
items, so it should not be inside {...}.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>2. Instances of UNLIMITED dimensions (other than the
first dimension) must be surrounded by {...} in order to
specify the size.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>3. Instances of vlens must be surrounded by {...} in
order to specify the size.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>4. Compound instances must be embedded in {...}</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>5. Non-scalar fields of compound instances must be
embedded in {...}.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>6. Datalists associated with attributes are implicitly a
vector (i.e., a list) of values of the type of the attribute
and the above rules must apply with that in mind.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>7. No other use of braces is allowed.</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Note that one consequence of these rules is that arrays
of values cannot have subarrays within braces. Thus, given,
for example, int var(d1)(d2)...(dn), a datalist for this
variable must be a single list of integers, where the number
of integers is no more than D=d1*d2*...dn values; note that
the list can be less than D, in which case fill values will
be used to pad the list.</p>
<!-- INDENTATION -->
<p>Rule 6 about attribute datalist has the following
consequence. If the type of the attribute is a compound (or
vlen) type, and if the number of entries in the list is one,
then the compound instances must be enclosed in braces.</p>
</td>
</table>
<a name="BUGS"></a>
<h2>BUGS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The programs generated by <b>ncgen</b> when using the
<b>-c</b> flag use initialization statements to store data
in variables, and will fail to produce compilable programs
if you try to use them for large datasets, since the
resulting statements may exceed the line length or number of
continuation statements permitted by the compiler.</p>
<!-- INDENTATION -->
<p>The CDL syntax makes it easy to assign what looks like an
array of variable-length strings to a netCDF variable, but
the strings may simply be concatenated into a single array
of characters. Specific use of the <i>string</i> type
specifier may solve the problem</p>
</td>
</table>
<hr>
</body>
</html>
